{"title": "微信小程序开发技巧 ", "author": "Rolan", "pub_time": "2019-11-18 00:43", "content": "开发小程序这么久了，整理了一些技巧清单，分享出来。页面配置中 backgroundColor 可以设置窗口颜色：这么设置完之后发现一点效果都没有，仔细研究一番，原来窗口颜色指的是最底层。（真想说句：卧槽~）解决这个问题很简单，使用 page 选择器即可：page 是页面的根节点，也就是h5里的 html，所以可以用来设置一些样式。header组件代码如下：可以看到渲染出来后发现多出 header 节点。在大部分开发中跟组件节点并没有什么用， 但是 某些情况下是会影响样式的， 比如说弹性布局，这里不贴demo了，反之此技巧必定用到，回头瞧瞧就行。我们可以在自定义组件样式文件使用 :host 选择器修改跟组件节点：可以对比上图盒子模型block 标签其实就类似于 react 中的 Fragment, Vue中的 template。如果没接触过 react/vue 没关系，看下面例子：渲染后结果, block 节点消失如果没有block节点，需要这么做:比较常用的用来配合 wx:if搞个背景图片都费劲 [发火]平常在h5中设置背景图片直接引入地址就行但是在小程序中竟然不可以。。。为啥？？？xx了。 只能走后门了。1、可以将图片转成 base64 即可：2、内联节点中使用 backgorund-image这个方法我就不该说出来~ 因为在真机是无效的。。。（欲哭无泪）3、使用 image\r\n这个方法我也懒得详细贴demo了， 总之就是使用 image 改改样式设置到底部即可。最后：现在的项目本地图片使用是非常少的，反正我见过的项目最多也就几张。 所以设置背景图片最简单的方法就是使用base64。在h5中使用 object-fit 特性是非常多的，它可以对图片保持一定的比例，而不会发生变形， 如果想了解其具体内容到 MDN在小程序中对图片使用此特性是没有效果的解决这个问题也很简单，使用小程序自带的属性即可具体属性可到官方查看 mode属性一览在WEB开发中我们会使用 mockjs 进行拦截请求从而模拟数据。在小程序中也可以使用吗？  那当然了， 只不过要对小程序 wx.request 处理。1、安装 mockjs2、新建 wxMock.js3、使用 wxMock.js4、在app.js入口文件中引入mock在WEB开发中当把图片设置 100% 时，高度会自适应。小程序就是不行，不行你看：因为小程序底层已经对 image 添加了宽高了，所以默认就是 240px。解决方法是给 image 元素添加 mode 属性当添加此模式并给图片设置 100% 宽度后，小程序自动计算其高度，就可以让图片自适应了。我只能先说可以。此特性是小程序基础库2.6.5新增的，可能有些小伙伴不知道。optionalTypes 字段是个数组，指定属性类型，可以多个。这个问题我估计每一个开发者都经历过。常规页面跳转到 tabbar 页面只能使用 wx.switchTab ，此API有个问题是：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面所以当跳转到 tabbar 页面左上角返回键自然就没了，所以是无法返回上一层的。用得比较多的场景就是购物车了， 某个页面跳转到购物车不可以返回上一层那体验不是很差么。这个问题我就不贴demo了，说下其方案。微信小程序开发和 web 还是有一些区别的， 小程序的开发灵活度虽然现在没有那么高，但随着不断的迭代更新，会慢慢得到改善，并受到众多开发者的喜爱。这篇文章不会断更，只要有些好的技巧会总结下来并分享。"}
{"title": "微信-小程序开发基础知识笔记 ", "author": "Rolan", "pub_time": "2019-11-22 00:41", "content": "1.bindtab和catchtab，catchtab可以阻止事件冒泡2.互斥事件绑定 mut-bind一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。在想要规定冒泡区间时可以用到。在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。mark 和 dataset 很相似，主要区别在于：1.mark可以冒泡，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。2.在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。3.不同于 dataset ，节点的 mark 不会做连字符和大小写转换。个人理解 .wxs文件就相当于cocos的prefab。执行起来比js性能要快。但是wxs是一门语言，平行于JavaScript。wxs基础语法有频繁用户交互的效果在小程序上表现是比较卡顿的，这时建议使用wxs，为什么？因为小程序分为视图层和逻辑层，比如需要拖动的功能，touchmove事件从视图层抛到逻辑层，逻辑层经过处理，通过this.setData到视图层。1. 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。2. 此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 很方便。代码示例：上边在分析复杂交互时我们知道，频繁的调用this.setData会使页面卡顿，甚至导致小程序僵死。那么不想写或者说不会写wxs的开发者该怎么办呢？此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。原因：自定义组件中的setData不会进行深复制。（深复制会在这个值被组件间传递时才发生）1.在组件wxss中不应使用ID选择器、属性选择器和标签名选择器，就只使用class选择器准没错。2.在自定义组件的 js 文件中，需要使用 Component() 来注册组件。3.使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。4.自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。5.<slot></slot>相当于react的this.props.children。6.默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。使用时，用 slot 属性来将节点插入到不同的slot上。7.设置自定义组件的捕获和冒泡机制需要使用 triggerEvent 方法。个人理解：多个页面可能会共用一个功能，这个功能抽象后称为组件。多个组件共用一个方法或者多个方法，这类方法的集合称为behaviors。就tm理解成高阶组件就完了。官方说：有时需要实现这样的组件：说custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。具体怎么个复杂需要单独拎出来一个ralations属性来处理，咱也不知道。使用方法：注意：必须在两个组件定义中都加入relations定义，否则不会生效。还有一种情况，如果你两个自定义组件都用了相同的behaviors，你可以使用这个behavior来代替组件路径作为关联的目标节点。官方定义他叫数据监听器，呵呵。使用方法：如果需要监听所有子数据字段的变化，可以使用通配符 。特别地，仅使用通配符 可以监听全部 setData 。**就是局部变量，不参与渲染，也不会传递。官方说这样声明后再用能提高性能，要不我才不用。使用方式：又一个新名词，呵呵呵。说白了就是有一个父容器组件A，因为条件不同有可能A中会渲染组件B，也可能渲染组件C。举个例子，当页面需要单选和多选组件的时候,方法1是按条件引用两个封装好的组件（<单选/>，</多选>），方法2是你也可以只引用一个组件<啦啦啦/>，只不过这个<啦啦啦/>组件去帮你按需渲染<单选/>或者<多选/>。需要在父容器组件A的.json文件声明：在使用组件时，必须指定父组件具体是渲染哪个子组件：<啦啦啦 generic:selectable=\"单选\" /><啦啦啦 generic:selectable=\"多选\" />在页面的.json文件<啦啦啦/>，<单选/>，<多选/>都要引用。代码当然，你也可以在容器组件.json中指定默认用哪个组件：今天真是开眼了，学到了这么多新词汇。。这是计算属性的应用？？？ 听着词这么厉害干这事真是大才小用了。这点应该是它实际有价值的地方。实现原理很简单，就是对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，这期间可以增加缓存机制，属性值没有变化的复用。在react中想拓展一个组件怎么办，会用高阶组件。小程序中，自然是使用behaviors。Behavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。"}
{"title": "uniapp登录流程详解uni.login ", "author": "Rolan", "pub_time": "2019-11-25 00:16", "content": "uni.login(OBJECT)登录H5平台登陆注意事项：微信内嵌浏览器运行H5版时，可通过js sdk实现微信登陆，需要引入一个单独的js，详见普通浏览器上实现微信登陆，并非开放API，需要向微信申请，仅个别开发者有此权限H5平台的其他登陆，比如QQ登陆、微博登陆，uni-app未封装，请在条件编译里按普通H5写法编写。OBJECT 参数说明参数名 类型 必填 说明 平台差异说明provider String 否 登录服务提供商，通过 uni.getProvider 获取，如果不设置则弹出登录列表选择界面scopes String/Array 见平台差异说明 授权类型，默认 auth_base。支持 auth_base（静默授权）/ auth_user（主动授权） / auth_zhima（芝麻信用） 支付宝小程序timeout Number 否 超时时间，单位ms 微信小程序、百度小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）success 返回参数说明参数名 说明authResult 登录服务商提供的登录信息，服务商不同返回的结果不完全相同errMsg 描述信息uni.checkSession检查登录状态是否过期属性 类型 必填 说明success function 否 接口调用成功的回调函数fail function 否 接口调用失败的回调函数complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）uni.getUserInfo(OBJECT)获取用户信息。UNI-APP 开发微信公众号（H5）JSSDK 的使用方式在 uniapp 中可以使用模块方式引用微信 js-sdk ，微信官网直接下载的使用有问题，可以使用 jweixin-module。安装下载使用方式下载地址： https://unpkg.com/jweixin-mod...使用、一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq....provider String 否 登录服务提供商，通过 uni.getProvider 获取withCredentials Boolean 否 是否带上登录态信息。 微信小程序、头条小程序lang Number 否 指定返回用户信息的语言，默认为 en。更多值请参考下面的说明。 微信小程序timeout Number 否 超时时间，单位 ms。 微信小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）userInfo 参数说明参数 类型 说明 平台差异说明nickName String 用户昵称openId String 该服务商唯一用户标识 5+AppavatarUrl String 用户头像说明：调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。注意：会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次uni.getProvider(OBJECT)获取服务供应商。仅App平台支持。在App平台，可用的服务商，是打包环境中配置的服务商，与手机端安装了什么app没有关系。云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。关于目前文章内容即涉及前端，PHP知识点，如果有兴趣即可关注，很荣幸，能被您发现，真是慧眼识英！也感谢您的关注，在未来的日子里，希望能够一直默默的支持我，我也会努力写出更多优秀的作品。我们一起成长，从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。分享 Web 前端相关的技术文章、工具资源、精选课程、热点资讯。若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。"}
{"title": "小程序云开发：菜鸟也能全栈做产品 ", "author": "Rolan", "pub_time": "2019-11-25 00:25", "content": "日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务”。与之对应的创造者分别称为“前端程序员”、“后端程序员”，然而，一个完整产品的开发不仅仅是只有前端和后端，还有设计师，架构师，运维等。有没有可能这些所有的事情都一个人干呢？有可能，事实上如今就有很多的“全栈工程师”，他们身兼数职，是多面手。能独立完成一个产品的方方面面。这种人固然十分了得，他们通常具有多年的经验，涉猎广泛，是老手，也是高手，当有一个产品想法的时候，他们可以用自己的全面专业技能，尽情的发挥去实现自己的想法。所以，从某种意义上讲“全栈也是一种自由”，你可以自由的实现你的想法，这简直太美妙了！然而，很多时候当我们有一个产品想法的时候，我们往往发现，前端写完了，后端怎么搞？数据库怎么搞？域名怎么搞？域名还要备案？应用部署怎么搞？我的买什么样的服务器啊？静态资源 CDN 怎么搞？文件上传服务器怎么搞？万一访问用户多了能撑住吗？等等……问题很多，导致你的一个个想法，都只是在脑海中昙花一现，从来都无法将她们实现，或者说你激情饱满的实现了其中自己最擅长的一部分，当碰到其他难题的时候就止步了。于是仰天长啸：我就想独立做一个完整的产品为什么这么难？年轻人，这一切都不怪你……为啥是用“小程序云开发”来破局？首先，我们的目的是全栈实现一个产品。全栈可以有多种技术方案，你可用任何你能会的技能来达到全栈的目的。你可以开发安卓，IOS，或者 PC 站，然而小程序是最实际的！为啥？手机上能做的事情为啥要用 PC 版？OK,既然手机版比较好，那能不能再简单一点？能，就是小程序，不需要开发IOS，安卓两个版本。可以快速产出，快速试错。其次，前面说到了，全栈实现一个产品并不容易，对很多人来说甚至是巨难！选择了小程序已经是比较划算的方案。而再集成云开发，全栈立马就有了。这就是为什么选择“小程序云开发”来破局。小程序云开发是什么？官方文档是这么说的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。看完上面的描述，也许你仍然无法非常清楚的知道什么是“小程序云开发”，没关系，你只需要注意加粗的部分，大概知道它“无需搭建服务器”，从传统观念将，这个似乎“毁三观”咋可能没服务器啊？是的，可以没有传统意义上的服务器，这种模式是 serveless 的。那么，小程序云开发提供了哪些东西来破局呢？且看下面的表格：上面的表格中提到了“云开发”中的一些能力：“云函数”，“数据库”，“存储”，“云调用”，我们可以将这些词带入你曾经开发过的应用，看看它们分别代表了哪些部分。对于程序员来说，如果有疑问的话，没有什么是一个 helloword 解决不了的。哆嗦再多，不如实战。下面我们就来使用小程序云开发实现一个简单的零售小程序。既然是一个零售小程序，那么我们可以思考一下零售小程序的大致业务流程，以及粗略的梳理一下，其功能点。现根据自己的想法，大致画一下草图，如果没有灵感可以参考一下别的 APP 是如何设计的。我根据自己的想法设计之后是这样的：功能模块：首页，商品列表页，购物车，确认订单，个人中心，个人订单，管你模块（商品添加，分类添加）其中商品需要上传图片。梳理完功能之后，我们对于要实现的东西已经有个初步的概念了。接下来，我们需要大概画一下页面设计、及功能流转。初次设计可能没有太多经验，没关系，开始做就行了，做着做着就会想法越来越多，然后优化的越来越好。。我也是经过了多番修改调整，最终找到了一些思路。我的（拙劣）设计如下，图片如果看不清楚可复制图片链接在新窗口打开查看：说明，以上图片是根据成品（我真的开发了一个云小程序并上线使用了）截图的，而实际我再设计的时候也是经过几番修改才最终定成这样。同时，补充说明一下，这里前端页面使用的是 vant-weapp控件，非常好用。推荐！如果你和我一样是一个纯后端程序员，建议使用 vant-weapp 来作为 ui，非常方便。否则自己写页面样式的话可能就做不出来了。全栈不是那么好干的啊。选择自己能驾驭的，能实现最终功能，就是一个合格的全栈。我们先下载微信小程序开发工具，下载地址在这里,安装好了之后，新建项目，界面如下，APPID 需要你自己去注册一个。然后注意，选择“小程序云开发”，如下图所示：创建好了之后，项目目录如下,先看 1 标注的地方：如果你曾经有过小程序的开发经验，那么miniprogram文件夹下面的结构你肯定熟悉了，miniprogram下面的子目录分别是小程序对应的组件、图片、页面、样式以及app.js,app.json,sitemap.json,其中components下面的vant-weapp就是上面提到的 ui 组件。最后一个比较重要的文件夹就是cloudfunctions，这个目录是用来存放“云函数的”，云函数就是我们的后端。每一个云函数提供一个服务。一个个的云函数组成了我们整体的后端服务。云函数可以看做是 FaaS（function as a service）。途中，2 标记的位置的“云开发”按钮，我们点进去，就可以看到“云开发的控制台”，如下图所示：如果上图看不清楚，可以复制链接到新的浏览器窗口查看，如图，小程序云开发默认的免费套餐有一定的额度可供使用。首页便是使用统计。然后我们能看到，有“数据库”，“存储”，“云函数”。这里的“数据库”其实就是类似于一个 MongoDB，你可以点进去创建一个个的 collection（即：关系型数据库中的table）;这里的“存储”其实就是“文件夹”，我们可以通过微信提供的 api把图片上传到“存储”中；这里的“云函数”就是我们需要实现的后端业务逻辑，他就是一个个的函数（函数由我们自己写好后上传）。一般开发过程中我们在开发者工具中的cloudfunctions目录下创建云函数（比方说是:user-add）开发完成之后在云函数目录点击右键——上传即可。然后就可以在小程序的代码中调用这个user-add云函数。注意：在开始云开发之前，我们现在 小程序代码的 app.js 中加入wx.cloud.init,如下：上面的图中，我们已经看到了“商品添加”页面的效果，它需要我们输入商品名称、价格、并上传图片，然后保存。传统架构中，上传图片需要前端页面摆一个控件，然后后端提供一个 api用来接收前端传来的文件，通常来说这个后端 api 接收到图片之后，会将图片文件保存到自己的文件服务器或者是阿里云存储、或者是七牛云存储之类的。然后返回给你一个文件链接地址。非常麻烦，然而，小程序云开发上传文件超级简单，上代码：这里有个控件，绑定了uploadImage方法，其代码为：这里，wx.chooseImage用于调起手机选择图片（相册/相机拍照），然后wx.cloud.uploadFile用于上传图片到上面说到的云开发能力之一的“存储”中。上传图片成功之后返回一个文件 ID，类似：这个链接可以直接在小程序页面展示：也可以通过微信 api，装换成 http 形式的图片链接。上面我们实现了商品图片上传，但是，商品图片并没有保存到数据库。正常录入商品的时候，我们会填好商品名称，价格等，然后上传图片，最终点击“保存”按钮，将商品保存到数据库。传统模式下，前端仍然是需要调用一个后端接口，通过 post 提交数据，最终由后端服务（比如 java 服务）将数据保存到数据库。小程序云开发使得操作数据库十分简单，首先我们在云开发控制台创建“商品表”，即一个 collection,取名为：products。然后我们就可以保存数据到数据库了，代码如下：以上就实现了数据入库，就这点代码，超简单，1 分钟写完，诚不欺我。其中这里的products就是我们的“商品表”，之前说过，类似 MongoDB 数据库，这里操作的是db.collection，这和 MongoDB 的语法差不多。小程序云开发提供了几大能力：“数据库”，“存储”，“云函数”，前两项我们已经有所体会了。下面我们能创建一个云函数来实现订单创建。这里说明，云函数其实就是 一段JavaScript 代码，上传至云服务器之后，最终也是运行在 nodejs 环境的，只是这一切，我们不需要关心。我们只需要关心我们这个云函数提供的功能是什么就可以了。创建云函数很简单，直接在开发工具中右键“新建Node.js 云函数”。然后以创建订单为例，假设我们创建一个云函数名为c-order-add,创建好了之后，目录是这样：云函数的主要代码在 index.js 中，其完整代码是这样：这个云函数写好之后，需要上传到服务器，直接在云函数目录点击右键，然后点击“上传并部署”即可，这就相当于部署好了后端服务。前端小程序页面调用的写法是这样的：这里，向程序前端，通过wx.cloud.callFunction完成了对云函数的调用，也可以理解为对后端服务的调用。至此我们我们介绍完了，小程序云开发的功能。虽然，我只贴出了少量的代码，即保存商品，和提交订单。由于时间和篇幅有限，我不可能把整个完整的程序代码贴出来。但是你可以参照这个用法示例，将剩下的业务逻辑补充完整，最终完成“项目构思”一节中展示的成品截图效果。我开发的小程序审核在提交审核的时候遭遇了两次退回，第一次是因为：“小程序具备电商性质，个人小程序号不支持”。所以，我只好申请了一个企业小程序号，使用的是超市的营业执照。服务类目的选择也被打回了一次，最后选择了食品还提交了食品经营许可证。第二次打回是因为：“用户体验问题”。其实就是“授权索取”的问题，微信不让打开首页就“要求授权”，同时不能强制用户接受授权，得提供拒绝授权也能使用部分功能。上面两条解决之后，更新新了好几版，都没有出现过被拒的情况。并且，有次我是夜晚 10 左右提价的审核，结果10 点多就提示审核通过，当时没看具体时间，就是接盆水泡了个脚的时间审核通过了。所以，我推断小程序审核初次审核会比较严，之后如果改动不大应该直接机审就过了。这里我们可以对小程序云开发和传统模式做一个对比：就对比这么多吧，总之，我非常喜欢小程序云开发，小程序真的可以让你轻松干全栈。或者咱们别动不动就提“全栈”，姑且说，小程序云开发可以让你更简单、更快速、更便宜的实现你的产品落地。我自己开发的云小程序上线之后，使用了一两个月，没出现任何问题。我也不用操心服务器什么的。所以，我已经给身边很多人安利了小程序云开发了。这里我就不贴出我的小程序码了，因为已经正式给我同学的超市使用了，所以不方便让别人去产生测试数据。如果你感兴趣想看的话，可以联系我。作者： 逃离沙漠出处：https://www.cnblogs.com/demingblog/p/11914354.html本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。"}
{"title": "小程序顶部导航栏，可滑动，可动态选中放大效果 ", "author": "Rolan", "pub_time": "2019-11-25 00:36", "content": "可以看到我们实现了如下功能1，顶部导航栏 2，可以左右滑动的导航栏 3，选中条目放大 原理其实很简单，我这里把我研究后的源码发给大家吧。代码里注释很明白了，大家自己跟着多敲几遍就可以了。后面会更新更多小程序相关的知识，请持续关注。"}
{"title": "浅谈微信小程序流量变现的常见模式 ", "author": "Rolan", "pub_time": "2019-11-26 00:01", "content": "什么是小程序，小程序是基于微信平台发展而衍生出的即用即走、无需下载的第三方工具。由于其具有操作简单、使用便捷的天然优势，因而现在使用微信小程序人数的增长速度犹如闪电般一样。同时，现在小程序的变现流量也是大幅度的增长，这为商家企业带来了红利期。那么，今天小编将为大家介绍几种常见的小程序流量变现模式，供大家学习与参考。在微信社交关系链和微信支付体系里，电商小程序流量变现优势明显。电商类的小程序用户直接完结购买流程，包含产品选购、购买、付出一系列的流程，直接变现。如：拼多多、享物说、每日优鲜等社交电商小程序依靠微信社交关系链裂变传播，日订单数也在千万量级。广告变现是小游戏、工具类、资讯类小程序变现的主要方式。小程序官方开放了Banner广告，只要活跃用户达到一定量级，可通过广告点击直接变现流量。付费流量变现方式带动了微信小程序内容付费的发展，如Reader、读书知乎live等小程序，都选用的是付费程序。将公众号绑定小程序可以在公众号推文中嵌入付费产品的小程序贴片。小程序不必下载不占内存，界面清新，用小程序付费体验比APP更好，用户形成习惯后，可直接通过内容付费小程序模式完成引流、推广和变现的流量闭环营销操作。微信官方发布了小游戏支撑微信交际关系链玩法，小程序游戏中道具、会员等等这些都能成为商家盈利的方法。游戏底部 banner 位、原生广告植入、续命激励来引导用户点击广告、通过设置付费关卡和道具等，都是游戏小程序的付费方式。"}
{"title": "微信小程序——基础知识 ", "author": "Rolan", "pub_time": "2019-11-26 00:02", "content": "一个小程序至少由俩个文件组成 app.js 和 app.json 1. app.js 小程序逻辑 2. app.json 小程序全局配置 3. app.wxss 小程序公共样式表 4. project.config.json 开发项目时工具配置文件。:warning:获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级解决方案：清空 App.js小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。路由 Pages | 微信开放文档项目开发目录为：则需要在 app.json 中写顶部导航 window | 微信开放文档用于设置小程序的状态栏、导航条、标题、窗口背景色。里添加如下：隐藏顶部栏，在该单页面的 json 里添加如下：底部 tabBar | 微信开放文档 小程序是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，及切换时显示的对应页面。list 数组，包含 tab 最少 2 个、最多 5 个<text>纯文本</text> 组件之间只能包含纯文本，在text中写其他标签，将会被忽略掉微信小程序 Image 图片实现宽度100%，高度自适应 mode=\"widthFix\"要使用弹性布局，通过 display: flex 或者 display: inline-flex 来将此元素定义为弹性容器。flex-direction 决定元素的排列方向flex-wrap 决定元素如何换行justify-content 定义主轴为水平方向，分布方式。align-items 定义主轴为垂直方向，分布方式。flex: 1 权重，分配主轴上剩余的空间（有图）数据绑定 | 微信开放文档view中的内容为 3 + 3 + d。特别注意：不要直接写  checked=\"false\" ，其计算结果是一个字符串，转成 boolean 类型后代表真值。列表渲染 | 微信开放文档在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index ，数组当前项的变量名默认为 item 数据绑定使用 {{}} 将变量包起来，可以作用于：上述代码的简略版使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名：wx:key 是列表中唯一的字符串或数字，且不能动态改变。例如：条件渲染 | 微信开放文档wx:if=\"{{false}}\" , wx:if=\"{{true}}\"在小程序里面识别boolean值时，只要属性的值 不为空时，boolean就判断为真，就算里面随便几个字符，例如 wx:if=\"11223\" ，也判断为真， 如果需要为false,就必须采用数据绑定的方式{{false}},才能被小程序解析为假。在框架中，使用 wx:if=\"\" 来判断是否需要渲染该代码块： 也可以用  wx:elif 和  wx:else 来添加一个 else 块：结果：及格注意： <block/> 并不是一个组件，它仅仅是一个包装元素，将多个组件包装起来,不会在页面中做任何渲染，只接受控制属性。 wx:if 和 wx:for 含有 <block/> 的写法不含有 <block/> 的写法页面描述：当有数据时，显示左侧列表。当没有数据时，则显示右侧内容1. wx:if 在初始渲染条件为  false ，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。所以当  wx:if 的条件值切换时，框架有一个局部渲染的过程，确保条件块在切换时销毁或重新渲染。 2. hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。总结: wx:if 有更高的切换消耗，而  hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用  hidden你会发现 hidden 没生效。经我实验发现 hidden 元素对块状布局才生效，所以这段代码里导致 hidden 没生效的罪魁祸首是 display:flex 。把这个去掉就可以了。其实这里想用 hidden 无非就是想影藏这个布局， display:none 也能做到隐藏。这里可以用一个取巧的方法，动态设置 display 属性，示例如下：这里的 hideview 是在对应的 js 里是一个变量，由 js 来动态控制。"}
{"title": "微信小程序后端开发流程 ", "author": "Rolan", "pub_time": "2019-11-13 00:42", "content": "1、前端调用 wx.login 返回了code，然后调用wx.getUserInfo获取到用户的昵称 头像 2、服务端根据code去微信获取openid， 接口地址： developers.weixin.qq.com/miniprogram…controller层总结：微信小程序的后端开发主要就是对用户进行授权 ， 1、前端调用 wx.login 返回了code，然后调用wx.getUserInfo获取到用户的昵称 头像 2.首先通过微信授权用js_code换取openId，来获取openId，前端传微信的参数 code字段 3.然后解密获取手机号 前端需要传openId encryptedData iv 等字段来获取用户的的授权手机号这些信息都获取后 接着就是调用后端的登陆接口，登陆接口如果只有授权登录就是我们将接口参数为下图最后三个字段为前端必填字段通过解密获取授权登录的手机号，然后根据自己的业务逻辑处理即可，这样我们就可以根据授权的手机号进行授权登录"}
{"title": "微信小程序实现去抖音视频水印 ", "author": "Rolan", "pub_time": "2019-11-11 00:52", "content": "先放效果图可以扫码或者微信搜索 “ 和水印说拜拜 ” 小程序体验一下。有效再继续往下看吧。抖音视频上传后，是有2个视频地址，（长视频还会多一个），一个是无水印的，一个是有水印的，万能的网友经过爬虫后，拿到了这个链接，那就可以实现保存无水印的视频了（去水印）。1、里面是一个PHP文件，把你输入的抖音链接，转为无水印的链接输出。不建议把这个转换算法写死在本地，因为这个转换算法随时会变，所以用PHP实现，然后客户端或者微信小程序调用。把这个PHP文件丢到你的服务器，然后访问https://xxxx.com/douyin.php?_u=https://sss抖音链接 然后就会返回对应的信息，例如：这个videoUrl就是无水印的视频地址，可以直接在小程序 标签里面播放，但是在小程序里面，这个是保存不了的，很奇怪，我试了很多次，都是提示类型无效。所以，我是直接让用户复制这个链接，然后在QQ浏览器打开，就能下载视频。（如果有人知道小程序怎样能保存这个视频，请联系我，我做了一个微信小程序的代码片段，你们可以拿去试下。地址：https://developers.weixin.qq.com/s/f5e4RbmR7kbH）如果是客户端使用的话，是可以直接保存的，后缀名为mp4，能直接下载保存。上面的PHP，其实主要就是这里，把接收的抖音链接，进行一个正则转换替换字符，然后再输出链接。这个转换的算法，应该是抖音随时更换的，不保证永远有效，但截至发帖，都是有效的，建议大家去扫一下小程序，看看能不能转换，能的话，即表明还能用。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "解决小程序中webview页面多层history返回问题 ", "author": "Rolan", "pub_time": "2019-8-21 00:15", "content": "小程序开发中遇到的问题：小程序中嵌套了一个webview页面，webview页面中有静默授权（A1页面静默授权后重定向到A2页面），点小程序原生的返回按钮会返回到A1页面，然后页面就会反复静默授权预期表现：点小程序原生的返回按钮后返回到小程序上个页面解决方案：通过\thistory.pushState 添加历史记录名目，\thistory.onpopstate 监听历史记录条目发生变化时，调用小程序API\twx.navigateBack刚开始想的解决办法是用localStorage，跳转到A2时存储一个值，返回到A1时获取这个值，如果有值就清除这个值并且回退到小程序页面。听起来似乎也可行，但小程序的缓存和微信的缓存是同步的，如果在微信环境中直接访问A1页面，重定向到A2会存值，如果直接关闭页面，不会被清除，那么在小程序中访问时就直接回退了。"}
{"title": "微信小程序生成自适应海报 ", "author": "Rolan", "pub_time": "2019-8-30 00:08", "content": "小程序canvas的API并没有像其他的一样支持小程序独有的 rpx 自适应尺寸单位，在绘制内容时所应用的单位仍然是 px，那么如何实现不同尺寸屏幕的自适应呢？首先我们根据开发工具可知不同常用屏幕的尺寸：由此可知我们开发中常用的参考屏幕尺寸（iPhone6）为：375*667；那么想要适应其他尺寸的屏幕时只需按照iPhone6的绘制大小按比例进行换算即可：首先利用wx.getSystemInfo （获取系统信息）的API获取屏幕宽度，然后除iPhone6的屏幕宽度，即可得到相对单位在绘制方法中将参数乘以相对单位即可实现自适应："}
{"title": "用uniapp写个天气的微信小程序和支付宝小程序 ", "author": "Rolan", "pub_time": "2019-9-11 00:59", "content": "经过最近两年多的发展，小程序的地位也逐渐越来越高了，各个平台前赴后继做了自家的小程序平台，随着市场的需求越来愈多，我们开发各平台的小程序的激情也随（被）之（逼）高（无）涨（奈）。为何选择uniapp？uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。即使不跨端，uni-app同时也是更好的小程序开发框架。来自官方。喜欢taro， wepy，mpvue的朋友也莫喷我，大家各有所好，大家开心就好。在定位功能中，本程序用到腾讯地图的api 以及 腾讯天气的api接口，需要到官网中注册开发者账号，通过注册后得到的appKey来请求我们需要的数据，详细注册步骤请自行度娘由于需要用到定位功能，uniapp的getLocation方法获取到的是当前位置的坐标，然后对应百度地图具体城市得到城市名后，再用城市名查询天气的接口，得到未来几天的天气预报。\r\n天气接口使用腾讯天气接口api。\r\n在小程序中使用前，要在小程序设置界面，开发设置中添加request合法域名。由于没有什么审美，缺乏想象力，参考腾讯天气的界面来做的。功能十分简单，查看当前地区的天气和切换其他地区的天气，查看最近24小时的天气情况以及最近6天的天气情况，展示今天的农历时间。想快速完成小程序的搭建，里面的折线图采用的uchart.js,\r\n因为可以兼容支付宝小程序和微信小程序，农历查询也是采用的插件calendar.js。\r\n\r\n折线图在支付宝小程序中会有模糊的问题，需要做兼容处理微信小程序有城市选择组件，支付宝的没有可以直接使用的城市组件，uniapp官方介绍:支持安装 mpvue 组件，但npm方式不支持小程序自定义组件（如 wxml格式的vant-weapp）,找到一款支付宝可以使用的城市插件：mpvue-citypicker,城市选择组件"}
{"title": "微信小程序wxparse解析iframe中视频办法 ", "author": "Rolan", "pub_time": "2019-9-23 00:08", "content": "微信小程序里面，对于富文本标签，我们通常使用wxparse这个插件来进行解析，可以说非常的方便。但是今天在使用的时候，遇到了iframe中是视频地址的问题。如果是标准的视频标签。wxparse是可以正常解析的，但是如果是下面这样的形式的话，小程序是无法显示视频的。问题的原因就是wxparse没有对iframe标签进行解析匹配，我们需要自己修改wxparse来使它可以解析iframe标签。解决过程如下：修改wxparse中的html2json.js文件，添加对iframe标签的解析。2.\t在wxParse.wxml添加iframe视频模板3.在wxParse.wxml中，对循环模板添加处理。需要注意的是，循环模板可能会有很多个，比如我们最好都添加上iframe的模板解析"}
{"title": "小程序模块化 ", "author": "Rolan", "pub_time": "2019-10-8 00:10", "content": "阅读基础：有小程序项目经验，有查阅官方文档习惯的小伙伴随着公司小程序项目日益繁多，仅仅靠着官方提供的框架、组件、API，已经远远不能满足项目高效迭代的要求了，于是我们组内萌生了对小程序进行模块化的想法。实际项目中我们对小程序模块化已经涉及各个模块，我总结一下，从三个方向跟大家分享我们不一样的模块化思路：\tPage+ ，\tbasePage ，\t适配层 。Page() 作为页面的入口，我们可以通过对其入参对象的封装实现：生命周期的改造、全局状态管理和新增页面功能。官方删除了小程序分享回调 complete，一起来尝试将其恢复吧。一般我们的逻辑是这样的：在单页面内实现分享回调这样操作是可行的，如果多页面、多项目都要实现该功能，重复拷贝代码，则显格外得繁琐。我们来将这个功能抽离封装一下吧。我们来增加一个新的生命周期回调——\tonReshow （页面非首次显示回调，常用于详情页操作影响上一页列表数据的场景）。自此，我们修改了原生的生命周期回调和增加了新的生命周期回调。当然我们还能为 Page+ 赋予更多的功能，例如：页面刷新 ：下拉自动刷新当前页。定时器自动清除 ：离开页面时，自动清除页面执行的定时器。全局状态管理 ：页面间数据共享，相关数据关联的组件即时渲染更新。相关的代码实现，大家可以自己思考一下怎么实现；我的实现细节，如果大家感兴趣的话就在下方给我留言吧，你们的回复是我更新的动力哦。小程序页面彼此独立，使用 Component 都需要各自引用，为了实现页面公共 Component 的统一管理，这个时候就可以引入 basePage 的概念：以 basePage 作为父组件，其他公共 Component 作为子组件，页面通过 basePage 对公共 Component 进行管理。1、定义一个 Component ，作为 basePage 。2、每个页面统一引用 basePage ，且规定页面的元素都需要写到 <basePage/> 标签内部 。3、通过 basePage 引用页面公共的 Component ，并进行业务逻辑编辑。实际使用过程中，我发现有两个问题：1、Page 和 basePage 通信是非常频繁的，需要通过 WXML 数据绑定和 triggerEvent 触发事件，略显麻烦。2、setTimeout、webSocket 等后台进程，可能触发\t非当前显示页面 的渲染更新，而绝大部分情况，我们只需要\t当前显示页面 的渲染更新。针对这两种场景的优化，我们可以把当前显示页面的 basePage 实例对象赋值到 global 的某个具体变量；每当 Page 触发 show 生命周期回调的时候，我们就对这个变量赋值的实例对象进行更新，这样我们就可以通过 global 的变量直接操作当前显示页面的 basePage 了。如果你的项目对代码后续维护、迭代和可移植性有较高需求，或者需要多项目并行，这个时候通过适配层去调用各个功能模块就显得尤为重要。适配层方面我做的还是比较粗糙的，如果有建议欢迎指出。项目不是 bugfix 级别的迭代，都有适配层设计的必要。如果是\t新项目 ，心底不认为自己是“咸鱼”而是代码的“亲爹”，\t适配层完全可以作为标配 去实现；这就是展现自己对代码全局观的时候了，把自己对代码的理解都用适配层去诠释吧。如果是\t旧项目迭代 ，在项目排期允许的情况下，尽可能理解原代码的基本实现细节；对比新的项目是要束手束脚一些，适配层的设计要在\t尽可能少改变原有代码 的情况下进行；如果排期比紧急，适配层的完整实现\t可以在几个版本迭代中逐步实现 。如果功能模块的设计过于松散、耦合复杂，这就意味着适配层将需要做各种兼容，这和适配层设计的初衷背道而驰，不做也罢。如果你的代码有移植性要求，为这些不同环境准备对应的配置文件吧，配置文件可以通过自制脚手架实现，也可以粗暴地手动替换，在保证尽可能不出错的情况下实现即可。功能模块的入口所有整合的功能模块都需要通过适配层进行调用，适配层就是你的“王之财宝”。适配层是从代码的全局考虑，如果是项目是分工完成，项目的开发人员都需要遵守适配层规范进行代码开发；文档我一直都认为都是非常必要的，但还是经常会懈怠，没有进行完整的文档编写，但我基本会在所有项目成员都能理解适配层的情况下，进行简单的口头说明。一次需求迭代中，几乎涉及手头上的所有小程序项目；刚好就在需求前的半个月，我们小组完成了对所有项目模块化改造；虽然需求来得很急，我们还是很完美的实现了。毕竟\t模块化之前，每个项目的改造都是独立的工作量；模块化之后，就只有适配层迭代的工作量了 。不过真是辛苦了测试小伙伴，因为对所有项目进行模块化改造，意味着测试小伙伴对所有项目进行回归测试，感谢测试小伙伴，比心！这篇文章，对 Page+ 的具体实现展示比较详细，感觉对 basePage 和适配层讲的都比较偏概念。毕竟这部分内容都和业务逻辑联系比较紧密，很难抽象深入讲解。刚好还有假期还有一段时间，如果自己还有时间就再写一篇关于最近项目的模块化剖析吧，哈哈。"}
{"title": "小程序九九八十一坑之头像模糊，谁的锅？ ", "author": "Rolan", "pub_time": "2019-10-15 00:46", "content": "「柒留言」更新的换国旗头像小功能，获取头像显示模糊...国庆之前，更新了「柒留言」小程序加国旗头像的小功能，但是头像模糊这个坑我在发布新版之前还没解决。一直以为是代码出了问题，各种搜索，巧的是正好也有类似的答案，然后我就被带进锅里了，弄了半天还是模糊，无奈之下弄了个用户自行上传图片生成头像，这样生成的头像就能清晰显示，先发布新版。发布新版后仔细研究了一下头像，发现显示在浏览器上是小图，一度以为是自己上传了略缩图，于是乎重新上传高清图像，然并 L。最后在头像地址上找到了问题。这是我的头像地址，滑动到最右，你发现了啥？/ 后面带了个 132，猜想一下这个是头像尺寸，于是乎搜一下微信文档，果然。是在下输了，怪我没有仔细看文档，谁知道一个头像获取还要分尺寸的，这里把 132 改成 0 就是高清头像了，改的逻辑就不用多说了吧，我相信你们会的。其实，132 的头像用在小程序中已经很清楚了，只不过我绘制头像时用的尺寸是 256px，差不多是把头像放大了一倍，所以显示是模糊的。这个锅，我先背为敬。最近公司在肝项目上线，尽量压缩中午的午休时间更新一下遇到的坑。大概率不是那么的硬核，但希望能帮大家少踩坑。干货都是相对的，觉得对你有帮助点个在看吧，大佬路过就行。Demo 已更新，线上版本未更新，加了点好玩的：教程 | 小程序七十二变之 canvas 绘制国旗头像GitHub 获取制作国旗头像源码"}
{"title": "从 WeRequest 登陆态管理来聊聊业务代码 原 荐 ", "author": "Rolan", "pub_time": "2019-10-30 00:12", "content": "在开发微信小程序之前，个人从来没有接触过开发中涉及到第三方服务器交互的流程。在开发的过程本身倒是没有什么太大的意外，只是在维护服务器登陆状态这一点很讨厌。因为涉及到自身服务器的登录状态以及微信官方服务器登陆状态三方的关系。下图是微信登陆机制:在这种场景下，个人非常关注的点在于: 如何能够无感知的进行登陆(并且无多余请求)。微信的登陆状态倒是还好解决，可以利用 wx.checkSession 来进行判定，但是在与后台服务器交互时候，如果后台交互中返回 HTTP 状态码 401 (未授权)或者其他未登陆指示时候。则需要对其进行额外处理。当时记得为了优雅的解决这个问题，想了很多方案，也与一些伙伴讨论过这个问题。虽然当时的确实现了无感知的登陆，但是要么需要多请求服务器，要么就是代码上实现逻辑过于复杂，代码维护。虽然不满意，但是在当时也没想到什么非常好的解决方法。后面经过老大的介绍，看到这个组件时，我顿时眼前一亮，这正是我所需要的解决方案,该方案的图示如下:只需要配置一些初始化项目，便可以直接拿去使用了。使用时候直接拿到 weRequest 既可使用简单的介绍一下 weRequest 库的实现机制, 在这里代码简化一下,只会说明最主要调用的三个函数。requestHandler.request 管理请求，即每一次请求都要执行该函数sessionManager.main 管理 session 状态。session 的设置与删除，同时也在第一次确认拥有 session 时设置标识符，即只会在第一次缺失登陆态或者错误时候才会执行。responseHandler.response 管理返回数据，对返回数据进行解析，如果没有登陆态，删除 session，重新请求，结合第二个 sessionManager.main 来做。我们可以利用结合官方网站的图示进行代码分析如果用户从来没有登陆过时，或者 checkSession 过期：用户登陆态未过期，再次打开小程序:用户某次登陆后端，后端登陆态过期:之前在写关于异步代码操作时候，通常是基于 axios 直接返回 api 请求响应数据，对其进行正常和错误处理。当时多次异步操作从而返回正确与错误的流程却很少进行梳理。如果在一次请求内有多个异步操作：代码就会变得难以维护。事实上我们可以把 Promise 看成状态机。只有在某些情况下才会返回正确。写出如上的代码，就可以在很多业务项内进行操作，诸如某些操作有前置权限请求，或者某些错误代码需要重新请求或者埋点等操作。可能会有人认为，在http 请求框架中都会有 interceptor 拦截器, 完全用不到 new Promise 来判断与操作。但是往往来说，拦截器对于代码是全局的，如果是单单对于某些模块，在拦截器中写大量 if 判断以及业务处理，这绝不是一件好事。因为场景上，业务的易变性使得全局代码被大量修改不利于项目的维护，但是如果该方案使用不当，则又会造成业务代码的可控性降低。当然以上代码也可以使用 async 与 await 来处理，建议多研究一下 async 错误处理，这里推荐两篇关于 async 错误处理的博客(因为个人一直不喜欢 async 函数需要配合回调函数或者 Promise.reject 来处理错误，所以一般来说，我更多用 async 来处理非 api 请求的异步操作，这样的话基本上不太需要处理错误)。如何在Javascript中优雅的使用Async和Await进行错误的处理?之前在阅读 《MobX Quick Start Guide》 时候，我看到一个公式只要输入等同的 属性和状态，得到的一定是 相同的 VirtualDOM 数据。但是我想说的是对于一个业务而言，如果不考虑界面美观性，以及必要的中间状态，我认为符合以下公式:其中，结合交互状态和数据状态面向的是最终用户，用户看到怎样的界面取决于前两个。而后一个配置项是面向于开发者，你的代码能究竟支持多少种场景。能够通过配置来减少多少的代码量。难道只要输入等同的交互以及数据就能的到同样的业务吗？当然并非如此，因为对于前端而言，始终有不知道的数据状态。我们只能通过防御式编程与错误处理来搞定不清楚的数据状态(通过增加各种交互状态来解决数据数据状态未知情况)。对于 weRequest 这个库而言，整个 微信的登陆态是保存在 storage 中，整个库都在维护微信的登陆状态(和后台的交互状态并没有保存，只要出现没有权限状态时，就会删除微信登陆状态，重新login)。那么除去代码，整个的交互状态就是被存到内存以及 Storage 中的 session，doNotCheckSession 。数据状态是我们需要请求的api配置以及我们未知的后端状态。这里也推荐了一篇关于前端 axios 重新请求的方案参考，相比于 weRequest 更加清晰:axios请求超时,设置重新请求的完美解决方法同样对于我们的业务代码而言(组件内部实现)，往往有些数据也是配置项目。如果你对于这三者清楚的了解并且管理的很好，那么写出来的业务代码一定不会差。在 request 代码中很容易发现，代码能够维护和后端的状态并不是因为持有了后端的 session，而是一种试错机制，只要上一次请求和下一次请求之间的数据没有变过，那么在错误处理中重复请求就没有问题。同时呢，虽然是有 session，doNotCheckSession 这个数据在，但是被移除到非业务中，只作为交互使用。所以我在这里想说的是，思考如何减少中间状态，也就是销毁，新建的模型更简单。在刚开始处理业务代码时候，我总是较多处理 state，总是使用组件的显隐来控制 Dialog，有时候填写 form 表单很麻烦，因为当时组件的一些机制不够完善，在处理完一个form后，reset并不能清除 上一次数据的验证错误，需要多写一部分代码来搞定开发，后来开始转变了，对于大部分场景而言，不如直接销毁，新建，无需管理中间态。其实前端业务中，其实很多这样的例子，处理子组件与父组件的关系，甚至来说架构端，把单页面应用改成基于业务的多页面应用，也是一种销毁，新建的模式。利用浏览器本身的机制去除大部分的中间态。当我们费劲心思去维护一个中间状态的时候，利用各种工具提升性能，不妨多思考以下，去除是否是一种更简单的方案。之所以会有这样的感慨: 是因为在我刚毕业时曾经做过一个需求，里面有 5，6 个复杂的功能点，现在还要增加一个功能点。但是当时完全无法通过增加代码来解决问题，必须把代码拆分重组才可以搞定。遇到这种事情，有小伙伴可能会想，是不是当时的代码写的不好。其实并不是该代码写的不好，而是之前的代码写的相当好，契合的非常好，完全不知道怎么搞定，初出茅庐的我完全无法控制(需要对所有功能点通盘考虑，复杂度很高)，因此，我在这个需求上完全失控了。所以，能契合复杂的代码，考虑到各种可能是能力。能解析复杂的的代码，做一定的牺牲决策，化繁为简，也是一种能力。前者的能力是个人能力的强大，是不可复制和替代的。后者则是让团队实现更加简单，快速的实现各种功能。对于一个成熟的程序员而言，两者的提升都是很重要的。如果对于前端来说，无状态的优势是简单的话，web 后端的无状态的利好就更多了，可以通过外部扩展实现水平扩容，其实质也是把交互状态(用户数据)移除到其他介质上来实现请求可以打到不同的服务器上，而不是单服务器。同时实现了每次请求都是独一无二的，完全不需要考虑中间状态的迁移，有利于开发速度与正确性。weRequest 是一个非常小而美的库，代码非常简单干练,我个人非常喜欢他的源码结构，所以列出来:很难有人能一次搞定业务需求,只有在它出现后，才知道什么他是它最需要的。业务代码也一样。同时 weRequest 不是万能的，它符合大众的需求，但不一定符合每个业务的需求。你也可以根据代码改造甚至改进。如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。 博客地址weRequest如何在Javascript中优雅的使用Async和Await进行错误的处理?从不用 try-catch 实现的 async/await 语法说错误处理"}
{"title": "VUE 组件转换为微信小程序组件 ", "author": "Rolan", "pub_time": "2019-11-6 00:03", "content": "简介：首先我们介绍一下本文的关键点：抽象语法树，它是以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过操作这棵树，可以精确的定位到声明、赋值、运算语句，从而实现对代码的优化、变更等操作。本文通过对 VUE 组件的 JavaScript 、CSS模块进行转换，比如 JavaScript模块，包括外层对象，生命周期钩子函数，赋值语句，组件的内部数据，组件的对外属性等等来实现把一个 VUE 组件转换为 一个小程序组件。AST 抽象语法树，似乎我们平时并不会接触到。实际上在我们的项目当中，CSS 预处理，JSX 亦或是 TypeScript 的处理，代码格式化美化工具，Eslint， Javascript 转译，代码压缩，Webpack， Vue-Cli，ES6 转 ES5，当中都离不开 AST 抽象语法树这个绿巨人。先卖个关子，让我们看一下 AST 到的官方解释：It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code.中文的解释有：抽象语法树（abstract syntax tree或者缩写为 AST ），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。抽象语法树，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过操作这棵树，可以精确的定位到声明、赋值、运算语句，从而实现对代码的优化、变更等操作。这些并不是我们想要看到的。对于 AST 面纱的神秘感，似乎已经将要揭开。不错，在我刚接触到他的时候，同样感觉确实是难。但是当你开始了解了它以后，你就会越来越喜欢它。因为他实在太强大了。AST 本身并不难，难点在于转换的目标对象与源对象的语法差异，当中水深毋庸置疑。但是，这才能更加激起我们探索他的欲望。在开始之前，我们先看一下 抽象语法树到底长什么样子。通过\tastexplorer [1] （AST树查看网站），通过他你可以方便的查看代码的语法树，挑你喜欢的库。你可以在线把玩 AST，而且除了 JavaScript，HTML， CSS 还有很多其它语言的 AST 库，让我们对他有一个感性而直观的认识。请看下图，看看AST语法树长什么样子：此图看到的是一个 ExportDefaultDeclaration 也就是export default {}，还有他的位置信息，注释失信，tokens等等。我们看一下我们得到的 AST 树接下来我们插入一段 把 VUE 组件转换为微信小程序组件正则版本的处理没有使用 AST 将 VUE 组件转换成小程序组件的简易版本介绍下方是两段代码，简单的逻辑，实现思路，匹配目标字符串，替换字符，然后生成文件。上方是正则版本的一些模板匹配规则，经过后续的一系列处理把一个 VUE组件处理得到对应的小程序的 WXML ，WXSS，JSON，JS，4个文件。上方是处理得到的 WXML ，WXSS，JSON，JS，4个文件，并且生成到对应的目录下。代码实现用时较短，后续更改方案，并没有做优化，这里就不做详细展开讨论这个实现方案了。回到正题 介绍一下，AST 抽象语法树的核心部分：Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“ 转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。babel-core：Babel 的编译器；它暴露了 babel.transform 方法。[1] babylon：Babylon 是 Babel 的解析器。用于生成 AST 语法树。[2] babel-traverse：Babel 的遍历器，所有的transformers都使用该工具遍历所有的 AST (抽象语法树)，维护了整棵树的状态，并且负责替换、移除和添加节点。我们可以和 Babylon 一起使用来遍历和更新节点。[3] babel-generator：Babel 的代码生成器。它读取AST并将其转换为代码。整个编译器就被分成了三部分：分析器、转换器、生成器，大致的流程是：输入字符串 -> babylon分析器 parse -> 得到 AST -> 转换器 -> 得到 AST -> babel-generator -> 输出AST 三大法宝babylon.parse => traverse 转换 AST => generate(ast, {}, code).code) 生成感兴趣的童鞋，可以在网上或者看参考资料都有介绍。该铺垫的都铺垫的差不多了，进入正题。首先我们看一下要转换前后的语法树与代码如下（明确转换目标）：通过以上转换之前和转换之后代码和 AST 的对比我们明确了转换目标就是 ExportDefault 到 Component构造器的转换，下面看一下我们是如何处理的：对于 ExportDefault => Component 构造器转换还有一种转换思路 下面我们看一下：[1] 第一种思路是先提取 ExportDefault 内部所有节点的 AST ，并做处理，然后创建Component构造器，插入提取处理后的 AST，得到最终的 AST[2] 第二种思路呢，就是我们上面展示的这种，不过有一个关键的地方要注意一下：如果你想在 AST 开始处与结尾处插入，可使用 path 操作：注：关于微信小程序不支持 computed , 与 watch，我们具体的初期采用的方案是挂载 computed 和 watch 方法到每一个微信小程序组件，让小程序组件也支持这两个功能。关于 Data 部分的处理实际上就是：函数表达式转换为对象表达式 （FunctionExpression 转换为 ObjectExpression）通过如上的代码对比，我们看到了我们的转换前后代码的变化：那 CSS 我们也是必须要处理的一部分，let try通过前后代码的对比，我们看到了单位尺寸的转换（比如：top: 50px; 转换为 top: 117rpx;）。单位的转换( px 转为了 rpx )同样也有不少的 CSS Code Parsers 供我们选择 Cssom ，CssTree等等，我们拿 Cssom 来实现上方css代码的一个简单的转换。当然这只是一个 demo，实际项目中使用还的根据项目的实际情况出发，SCSS，LESS等等的转换与考虑不同的处理场景哦！注：本文有些模块的转换实现还未在小程序开发工具中测试。插播一个通过 AST 实现的好东东：当你拥有 AST 时，可以做任何你想要做的事。把AST转回成字符串代码并不是必要的，你可以通过它画一个流程图，或者其它你想要的东西。js2flowchart使用场景是什么呢？通过流程图，你可以解释你的代码，或者给你代码写文档；通过可视化的解释学习其他人的代码；通过简单的js语法，为每个处理过程简单的描述创建流程图。马上用最简单的方式尝试一下吧，去线上编辑看看\tjs-code-to-svg-flowchart [8]。此处有必要附上截图一张。通过以上我们的介绍，我们大概对抽象语法树有了初步的了解。总体思路是：我们用Babel的解析器 把 JavaScript 源码转化为抽象语法树，再通过 Babel 的遍历器遍历 AST (抽象语法树)，替换、移除和添加节点，得到一个新的 AST 树。最后， 使用，Babel 的代码生成器 Babel Generator 模块 读取 处理后的 AST 并将其转换为代码。任务就完成了！本文通过对 VUE 组件转换为微信小程序组件的转换部分包括如下内容：希望，本文对大家有所帮助，在技术探索的路上，我们一往无前， Paladin 精神永存！感谢大家的耐心阅读，也欢迎大家关注【全栈探索公众号】，每周都会有技术好文推出！[1]\tastexplorer.net/[2]\tbabeljs.io/docs/en/nex…[3]\tgithub.com/babel/babel…[4]\tesprima.org/demo/parse.…[5]\tsegmentfault.com/a/119000001…[6]\tzh.wikipedia.org/wiki/%E6%8A…[7]\titnext.io/ast-for-jav…[8]\tgithub.com/Bogdan-Lyas…"}
